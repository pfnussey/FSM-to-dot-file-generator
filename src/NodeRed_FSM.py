# Originally written in early 2025 but published to GitHub repo 17/02/2026.

import json
import os
from datetime import datetime

PROGRAM_NAME = "makeDotFile"

class NodeRed_FSM:
  """Encapsulates a JSON representation of a FSM for Node Red.."""
  def __init__(self, name, input_file_path, output_file_path=None):
    self.name = name
    self.data = ""
    self.FSM_as_Dict: dict = ""
    self.input_file_path = input_file_path
    self.output_file_path = output_file_path
    self.dotFileName = ""

  def load_FSM_Definition(self):
    self.data = open(self.input_file_path, "r")
    self.FSM_as_Dict = json.loads(self.data.read())

  def validate(self):
    """Validate the loaded FSM definition.
    Returns a list of error strings. Empty list means valid."""
    errors = []

    # Check top-level keys
    if "state" not in self.FSM_as_Dict:
      errors.append("Missing top-level key: 'state'")
    if "transitions" not in self.FSM_as_Dict:
      errors.append("Missing top-level key: 'transitions'")
    if errors:
      return errors  # Can't continue without these

    # Check state structure
    state = self.FSM_as_Dict["state"]
    if "status" not in state:
      errors.append("'state' object is missing 'status' key")

    # Check transitions is non-empty dict
    transitions = self.FSM_as_Dict["transitions"]
    if not isinstance(transitions, dict) or len(transitions) == 0:
      errors.append("'transitions' must be a non-empty object")
      return errors  # Can't continue

    # Check each transition entry has "status"
    for source_state, triggers in transitions.items():
      if not isinstance(triggers, dict):
        errors.append(f"Transitions for state '{source_state}' must be an object")
        continue
      for trigger_name, trigger_data in triggers.items():
        if not isinstance(trigger_data, dict) or "status" not in trigger_data:
          errors.append(f"Transition '{source_state}' -> '{trigger_name}' is missing 'status' key")

    # Check initial state exists in transitions
    if "status" in state:
      initial_state = state["status"]
      if initial_state not in transitions:
        errors.append(f"Initial state '{initial_state}' not found in transitions")

    # Check all target states exist as source states
    defined_states = set(transitions.keys())
    for source_state, triggers in transitions.items():
      if not isinstance(triggers, dict):
        continue
      for trigger_name, trigger_data in triggers.items():
        if isinstance(trigger_data, dict) and "status" in trigger_data:
          target = trigger_data["status"]
          if target not in defined_states:
            errors.append(f"Target state '{target}' (from '{source_state}' via '{trigger_name}') is not defined in transitions")

    return errors

  def getFSM_as_dict(self):
    return self.FSM_as_Dict

  def printFSM(self):
    print("JSON formatted print of :", os.path.basename(self.input_file_path), "\n", json.dumps(self.FSM_as_Dict, indent=4))

  def getDotFileName(self):
    return(self.dotFileName)

  def buildDotFile(self, user_notes=""):
    #build the file name
    now = datetime.now()
    date = now.strftime("%Y%m%d")
    time = now.strftime("%H%M%S")

    if self.output_file_path:
      self.dotFileName = self.output_file_path
    else:
      #auto-generate output path in same directory as input file
      input_dir = os.path.dirname(self.input_file_path)
      dot_name = self.name + "_" + date + ".dot"
      self.dotFileName = os.path.join(input_dir, dot_name)

    #extract and format the transitions
    transitions  = ""
    for k1, v1 in self.FSM_as_Dict["transitions"].items():
      for k2, v2 in v1.items():
        transitions = transitions + "\n" + k1 + " -> " + v2["status"] + " [label = \"" + k2 + "\"];"

    #Build the header info for the .dot file
    date = now.strftime("%d/%m/%Y")
    time = now.strftime("%H:%M:%S")
    title = self.name + ": script for rendering FSM diagram in Graphviz (.dot format)"
    newline = "\n"
    author = "Peter Nussey"
    programName = PROGRAM_NAME

    versionInfo = "Generated by " + programName + " " + time + " on " + date

    #Compute auto-generated stats
    transitions_dict = self.FSM_as_Dict["transitions"]
    state_count = len(transitions_dict)
    transition_count = sum(len(v) for v in transitions_dict.values() if isinstance(v, dict))
    initial_state = self.FSM_as_Dict["state"].get("status", "unknown")
    source_file = os.path.basename(self.input_file_path)
    pdf_file_path = os.path.splitext(self.dotFileName)[0] + ".pdf"
    dotCommand = 'dot -Tpdf \\"' + self.dotFileName + '\\" -o \\"' + pdf_file_path + '\\"'

    fileHeader = (newline + title + newline +
                  "Author: " + author + newline +
                  versionInfo + newline +
                  "Source: " + source_file + newline +
                  "States: " + str(state_count) +
                  "  |  Transitions: " + str(transition_count) + newline +
                  "Initial state: " + initial_state + newline)

    #Build diagram label content: auto-generated notes + optional user notes
    label_content = fileHeader + dotCommand + newline
    if user_notes:
      escaped_notes = user_notes.replace('"', '\\"')
      label_content = label_content + "---" + newline + escaped_notes + newline

    layoutInfo = """digraph finite_state_machine {
	node [fontname="Helvetica,Arial,sans-serif", fontcolor=blue, fontsize=7]
	edge [fontname="Times-Italic", fontcolor=red, fontstyle=italic, fontsize=7, arrowsize=0.5]
	rankdir=LR;"""

    diagramFooterComment = "fontsize=8\nlabel = \"" + label_content + "\""

    #Write the .dot file
    f = open(self.dotFileName, "w")
    f.write("/*" + fileHeader + "*/" + newline + layoutInfo + newline + transitions + newline + diagramFooterComment + "\n}")
    f.close()
    print("Wrote to file: ", self.dotFileName)
